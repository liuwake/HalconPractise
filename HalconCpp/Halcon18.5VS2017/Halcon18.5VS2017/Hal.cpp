/*************************************************
Copyright: HRG
Author: LiuWake
Date:06/04/19
Description: 输入图像位置,返回OCR结果
**************************************************/


/*************************************************
Function:       识别图像上的Led数码管数字
Description:    输入图像位置,返回OCR结果
Calls:          // Null
Table Accessed: // Null
Table Updated: // Null
Input:          string 输入文件位置,如"C:/Led/led1.jpg";
				需要是绝对位置,相对位置可能出错;注意斜杠反斜杠;
Output:        string 输出识别结果,eg 840
Return:        string 输出识别结果,eg 840
Others:         null
*************************************************/

//Halcon库
#include "HalconCpp.h"
using namespace HalconCpp;

//公共库
using namespace std;
#include <string>
#include <iostream>

//自写函数头
#include "Hal.h"


// Procedure declarations 
// External procedures 
void led_auto_ocr(HObject ho_InputImage, HObject ho_ROI_OCR_01_0, HTuple* hv_SymbolNames_OCR_01_0,
	HTuple* hv_Confidences_OCR_01_0, HTuple* hv_Words_OCR_01_0, HTuple* hv_Scores_OCR_01_0);
void led_autoLroi(HObject ho_InputImage, HObject* ho_Rectangle);

// Procedures 
// External procedures 
void led_auto_ocr(HObject ho_InputImage, HObject ho_ROI_OCR_01_0, HTuple* hv_SymbolNames_OCR_01_0,
	HTuple* hv_Confidences_OCR_01_0, HTuple* hv_Words_OCR_01_0, HTuple* hv_Scores_OCR_01_0)
{

	// Local iconic variables
	HObject  ho_Image, ho_TmpObj_Mono, ho_TmpObj_MonoReduced_OCR_01_0;
	HObject  ho_TmpObj_Domain, ho_TmpObj_DomainExpanded, ho_TmpObj_DomainTransformedRaw;
	HObject  ho_TmpObj_DomainTransformed, ho_TmpObj_ImageTransformed;
	HObject  ho_TmpObj_ImageTransformedExpanded, ho_TmpObj_ImageTransformedReduced;
	HObject  ho_TmpObj_MonoInverted_OCR_01_0, ho_Symbols_OCR_01_0;

	// Local control variables
	HTuple  hv_TextModel, hv_OcrHandle, hv_TmpCtrl_MatrixIdentity;
	HTuple  hv_TmpCtrl_ClipRegion, hv_TmpCtrl_Row1, hv_TmpCtrl_Col1;
	HTuple  hv_TmpCtrl_Row2, hv_TmpCtrl_Col2, hv_TmpCtrl_MatrixTranslation;
	HTuple  hv_TmpCtrl_MatrixComposite, hv_TmpCtrl_ResultHandle_OCR_01_0;
	HTuple  hv_TmpCtrl_Expressions, hv_TmpCtrl_NumLines, hv_TmpCtrl_LineIndex;


	//OCR 01: Code generated by OCR 01
	//OCR 01:
	//OCR 01: Prepare text model
	//OCR 01:
	CreateTextModelReader("manual", HTuple(), &hv_TextModel);
	SetTextModelParam(hv_TextModel, "manual_polarity", "light_on_dark");
	SetTextModelParam(hv_TextModel, "manual_char_width", 18);
	SetTextModelParam(hv_TextModel, "manual_char_height", 32);
	SetTextModelParam(hv_TextModel, "manual_stroke_width", 3.2);
	SetTextModelParam(hv_TextModel, "manual_return_punctuation", "false");
	SetTextModelParam(hv_TextModel, "manual_return_separators", "false");
	SetTextModelParam(hv_TextModel, "manual_uppercase_only", "true");
	SetTextModelParam(hv_TextModel, "manual_fragment_size_min", 5);
	SetTextModelParam(hv_TextModel, "manual_eliminate_border_blobs", "true");
	SetTextModelParam(hv_TextModel, "manual_base_line_tolerance", 0.2);
	SetTextModelParam(hv_TextModel, "manual_max_line_num", 1);
	//OCR 01:
	//OCR 01: Load classifier
	//OCR 01:
	ReadOcrClassMlp("Industrial_0-9_NoRej.omc", &hv_OcrHandle);
	//OCR 01: ***************************************************************
	//OCR 01: * The code which follows is to be executed once / image       *
	//OCR 01: ***************************************************************
	//OCR 01:
	//OCR 01: Load image
	//*read_image (Image, 'C:/Users/iwake/OneDrive - wake/Desktop/Vision/VisionProj/Led/led1.jpg')
	ho_Image = ho_InputImage;
	//OCR 01:
	//OCR 01: Perform actual processing (once per ROI)
	//OCR 01: Generate regions of interest

	//OCR 01:
	//OCR 01: Extract symbol regions (segmentation step)
	//OCR 01: Only consider first channel for color images
	AccessChannel(ho_Image, &ho_TmpObj_Mono, 1);

	ReduceDomain(ho_TmpObj_Mono, ho_ROI_OCR_01_0, &ho_TmpObj_MonoReduced_OCR_01_0);
	//OCR 01:
	//OCR 01: Orientation Correction (for consistent border and domain
	//OCR 01: handling, this is always applied, even with no rotation)
	//OCR 01:
	HomMat2dIdentity(&hv_TmpCtrl_MatrixIdentity);
	//OCR 01: Apply transformation to image and domain
	GetDomain(ho_TmpObj_MonoReduced_OCR_01_0, &ho_TmpObj_Domain);
	GetSystem("clip_region", &hv_TmpCtrl_ClipRegion);
	SetSystem("clip_region", "false");
	DilationCircle(ho_TmpObj_Domain, &ho_TmpObj_DomainExpanded, 16);
	AffineTransRegion(ho_TmpObj_DomainExpanded, &ho_TmpObj_DomainTransformedRaw, hv_TmpCtrl_MatrixIdentity,
		"true");
	SmallestRectangle1(ho_TmpObj_DomainTransformedRaw, &hv_TmpCtrl_Row1, &hv_TmpCtrl_Col1,
		&hv_TmpCtrl_Row2, &hv_TmpCtrl_Col2);
	HomMat2dTranslate(hv_TmpCtrl_MatrixIdentity, -hv_TmpCtrl_Row1, -hv_TmpCtrl_Col1,
		&hv_TmpCtrl_MatrixTranslation);
	HomMat2dCompose(hv_TmpCtrl_MatrixTranslation, hv_TmpCtrl_MatrixIdentity, &hv_TmpCtrl_MatrixComposite);
	AffineTransRegion(ho_TmpObj_Domain, &ho_TmpObj_DomainTransformed, hv_TmpCtrl_MatrixComposite,
		"true");
	AffineTransImage(ho_TmpObj_MonoReduced_OCR_01_0, &ho_TmpObj_ImageTransformed, hv_TmpCtrl_MatrixComposite,
		"constant", "true");
	DilationCircle(ho_TmpObj_Domain, &ho_TmpObj_DomainExpanded, 16);
	ExpandDomainGray(ho_TmpObj_ImageTransformed, &ho_TmpObj_ImageTransformedExpanded,
		16);
	ReduceDomain(ho_TmpObj_ImageTransformed, ho_TmpObj_DomainTransformed, &ho_TmpObj_ImageTransformedReduced
	);
	CropPart(ho_TmpObj_ImageTransformedReduced, &ho_TmpObj_MonoReduced_OCR_01_0, 0,
		0, (hv_TmpCtrl_Col2 - hv_TmpCtrl_Col1) + 1, (hv_TmpCtrl_Row2 - hv_TmpCtrl_Row1) + 1);
	SetSystem("clip_region", hv_TmpCtrl_ClipRegion);
	FindText(ho_TmpObj_MonoReduced_OCR_01_0, hv_TextModel, &hv_TmpCtrl_ResultHandle_OCR_01_0);
	//OCR 01:
	//OCR 01: Read text (classification step)
	//OCR 01: Gray values for reading must be dark on bright
	InvertImage(ho_TmpObj_MonoReduced_OCR_01_0, &ho_TmpObj_MonoInverted_OCR_01_0);
	hv_TmpCtrl_Expressions = "^[0-9][0-9][0-9][0-9]$";
	GetTextResult(hv_TmpCtrl_ResultHandle_OCR_01_0, "manual_num_lines", &hv_TmpCtrl_NumLines);
	{
		HTuple end_val66 = hv_TmpCtrl_NumLines - 1;
		HTuple step_val66 = 1;
		for (hv_TmpCtrl_LineIndex = 0; hv_TmpCtrl_LineIndex.Continue(end_val66, step_val66); hv_TmpCtrl_LineIndex += step_val66)
		{
			GetTextObject(&ho_Symbols_OCR_01_0, hv_TmpCtrl_ResultHandle_OCR_01_0, HTuple("manual_line").TupleConcat(hv_TmpCtrl_LineIndex));
			if (HDevWindowStack::IsOpen())
				DispObj(ho_TmpObj_MonoInverted_OCR_01_0, HDevWindowStack::GetActive());
			if (HDevWindowStack::IsOpen())
				SetDraw(HDevWindowStack::GetActive(), "fill");
			if (HDevWindowStack::IsOpen())
				SetColored(HDevWindowStack::GetActive(), 3);
			if (HDevWindowStack::IsOpen())
				DispObj(ho_Symbols_OCR_01_0, HDevWindowStack::GetActive());
			DoOcrWordMlp(ho_Symbols_OCR_01_0, ho_TmpObj_MonoInverted_OCR_01_0, hv_OcrHandle,
				HTuple(hv_TmpCtrl_Expressions[hv_TmpCtrl_LineIndex % 1]), 3, 2, &(*hv_SymbolNames_OCR_01_0),
				&(*hv_Confidences_OCR_01_0), &(*hv_Words_OCR_01_0), &(*hv_Scores_OCR_01_0));
			//OCR 01: Do something with the results
		}
	}
	return;
	return;
}

void led_autoLroi(HObject ho_InputImage, HObject* ho_Rectangle)
{

	// Local iconic variables
	HObject  ho_Image, ho_Red, ho_Green, ho_Blue;
	HObject  ho_Hue, ho_Saturation, ho_Intensity, ho_HighSaturation;
	HObject  ho_HueHighSaturation, ho_Yellow, ho_ConnectedRegions;
	HObject  ho_SelectedRegions, ho_Circles, ho_ImageReduced;

	// Local control variables
	HTuple  hv_Row, hv_Column, hv_Radius, hv_watch_r;
	HTuple  hv_watch_x, hv_watch_y, hv_led_width, hv_led_height;
	HTuple  hv_led_x1, hv_led_y1, hv_led_x2, hv_led_y2;

	ho_Image = ho_InputImage;
	Decompose3(ho_Image, &ho_Red, &ho_Green, &ho_Blue);
	TransFromRgb(ho_Red, ho_Green, ho_Blue, &ho_Hue, &ho_Saturation, &ho_Intensity,
		"hsv");
	//对饱和度图像进行二值化
	Threshold(ho_Saturation, &ho_HighSaturation, 100, 255);
	//在色调图像中抠图
	ReduceDomain(ho_Hue, ho_HighSaturation, &ho_HueHighSaturation);
	Threshold(ho_HueHighSaturation, &ho_Yellow, 20, 50);
	Connection(ho_Yellow, &ho_ConnectedRegions);
	//根据形状选择，‘max_area’为选择面积最大的连通域
	SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
	ClosingCircle(ho_SelectedRegions, &ho_Yellow, 3.5);
	SmallestCircle(ho_SelectedRegions, &hv_Row, &hv_Column, &hv_Radius);
	GenCircle(&ho_Circles, hv_Row, hv_Column, hv_Radius);
	//* reduce_domain (Image, Yellow, ImageReduced)
	ReduceDomain(ho_Image, ho_Circles, &ho_ImageReduced);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_HueHighSaturation, HDevWindowStack::GetActive());
	if (HDevWindowStack::IsOpen())
		DispObj(ho_ImageReduced, HDevWindowStack::GetActive());
	//stop ()

	//* eg 1.2 根据圆和比例选取LED区域
	//* 初始化设备尺度参数
	hv_watch_r = hv_Radius;
	hv_watch_x = hv_Column;
	hv_watch_y = hv_Row;

	hv_led_width = 0.9 * hv_watch_r;
	hv_led_height = 0.5 * hv_watch_r;


	hv_led_x1 = hv_watch_x - (0.7 * hv_led_width);
	hv_led_y1 = hv_watch_y - hv_led_height;

	hv_led_x2 = hv_Column + (0.7 * hv_led_width);
	hv_led_y2 = hv_watch_y;
	//*生成矩形

	GenRectangle1(&(*ho_Rectangle), hv_led_y1, hv_led_x1, hv_led_y2, hv_led_x2);
	return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
string action(string path)
{

	// Local iconic variables
	HObject  ho_InputImage, ho_Rectangle;

	// Local control variables
	HTuple  hv_Image_path, hv_SymbolNames_OCR_01_0;
	HTuple  hv_Confidences_OCR_01_0, hv_Words_OCR_01_0, hv_Scores_OCR_01_0;

	//*
	//*注意:
	//* 调用hdvp请先将当前目录添加到Procedures Directories

	//dev_close_window ()
	//dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
	//hv_Image_path = "C:/Users/iwake/OneDrive - wake/Desktop/Vision/VisionProj/Led/led1.jpg";

	//string path = "C:/Users/iwake/OneDrive - wake/Desktop/Vision/VisionProj/Led/led1.jpg";


	hv_Image_path = (HTuple)(path.c_str());

	ReadImage(&ho_InputImage, hv_Image_path);


	//* auto_roi
	led_autoLroi(ho_InputImage, &ho_Rectangle);
	//gen_rectangle1 (Rectangle, 124.685, 302.511, 159.685, 407.511)


	//* auto_ocr
	led_auto_ocr(ho_InputImage, ho_Rectangle, &hv_SymbolNames_OCR_01_0, &hv_Confidences_OCR_01_0,
		&hv_Words_OCR_01_0, &hv_Scores_OCR_01_0);



	//std::cout << hv_Words_OCR_01_0;

	string str = (string)hv_Words_OCR_01_0[0].S();
	//Htuple 转 string	
	return str;
	//返回string
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void* info)
{
	UnlockMutex(gStartMutex);
}

static Herror apple_action(void** parameters)
{
	// Wait until the timer has fired to start processing.
	LockMutex(gStartMutex);
	UnlockMutex(gStartMutex);

	try
	{
		action();
	}
	catch (HException& exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char*)exception.ProcName(),
			(const char*)exception.ErrorMessage());
	}

	// Tell the main thread to terminate itself.
	LockMutex(gStartMutex);
	gTerminate = TRUE;
	UnlockMutex(gStartMutex);
	CFRunLoopStop(CFRunLoopGetMain());
	return H_MSG_OK;
}

static int apple_main(int argc, char* argv[])
{
	Herror                error;
	CFRunLoopTimerRef     Timer;
	CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

	CreateMutex("type", "sleep", &gStartMutex);
	LockMutex(gStartMutex);

	error = HpThreadHandleAlloc(&gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleAlloc failed: %d\n", error);
		exit(1);
	}

	error = HpThreadCreate(gActionThread, 0, apple_action);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadCreate failed: %d\n", error);
		exit(1);
	}

	Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
		CFAbsoluteTimeGetCurrent(), 0, 0, 0,
		timer_callback, &TimerContext);
	if (!Timer)
	{
		fprintf(stderr, "CFRunLoopTimerCreate failed\n");
		exit(1);
	}
	CFRunLoopAddTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);

	for (;;)
	{
		HBOOL terminate;

		CFRunLoopRun();

		LockMutex(gStartMutex);
		terminate = gTerminate;
		UnlockMutex(gStartMutex);

		if (terminate)
			break;
	}

	CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);
	CFRelease(Timer);

	error = HpThreadHandleFree(gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleFree failed: %d\n", error);
		exit(1);
	}

	ClearMutex(gStartMutex);
	return 0;
}
#endif

//int main(int argc, char* argv[])
//{
//	int ret = 0;
//
//	try
//	{
//#if defined(_WIN32)
//		SetSystem("use_window_thread", "true");
//#elif defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
//		XInitThreads();
//#endif
//
//		// Default settings used in HDevelop (can be omitted)
//		SetSystem("width", 512);
//		SetSystem("height", 512);
//
//#ifndef __APPLE__
//		action();
//#else
//		ret = apple_main(argc, argv);
//#endif
//	}
//	catch (HException& exception)
//	{
//		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
//			(const char*)exception.ProcName(),
//			(const char*)exception.ErrorMessage());
//		ret = 1;
//	}
//	return ret;
//}

#endif


#endif