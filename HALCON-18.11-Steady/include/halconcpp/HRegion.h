/***********************************************************
 * File generated by the HALCON-Compiler hcomp version 18.11
 * Usage: Interface to C++
 *
 * Software by: MVTec Software GmbH, www.mvtec.com
 ***********************************************************/


#ifndef HCPP_HREGION
#define HCPP_HREGION

namespace HalconCpp
{

// Represents an instance of a region object(-array).
class LIntExport HRegion : public HObject
{

public:

  // Create an uninitialized instance
  HRegion():HObject() {}

  // Copy constructor
  HRegion(const HRegion& source) : HObject(source) {}

  // Copy constructor
  HRegion(const HObject& object);

  // Create HRegion from object id. For copy=false takes
  // over management of input key. Type of key must match!
  explicit HRegion(Hkey key, bool copy=true);

  // Access of object tuple element
  const HRegion operator [] (Hlong index) const;

  // Deep copy of all data represented by this object instance
  HRegion Clone() const;



/*****************************************************************************
 * Operator-based class constructors
 *****************************************************************************/

  // gen_rectangle1: Create a rectangle parallel to the coordinate axes.
  explicit HRegion(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

  // gen_rectangle1: Create a rectangle parallel to the coordinate axes.
  explicit HRegion(double Row1, double Column1, double Row2, double Column2);

  // gen_ellipse_sector: Create an ellipse sector.
  explicit HRegion(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& StartAngle, const HTuple& EndAngle);

  // gen_ellipse_sector: Create an ellipse sector.
  explicit HRegion(double Row, double Column, double Phi, double Radius1, double Radius2, double StartAngle, double EndAngle);

  // gen_circle_sector: Create a circle sector.
  explicit HRegion(const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& StartAngle, const HTuple& EndAngle);

  // gen_circle_sector: Create a circle sector.
  explicit HRegion(double Row, double Column, double Radius, double StartAngle, double EndAngle);

  // gen_circle: Create a circle.
  explicit HRegion(const HTuple& Row, const HTuple& Column, const HTuple& Radius);

  // gen_circle: Create a circle.
  explicit HRegion(double Row, double Column, double Radius);


/*****************************************************************************
 * Conversions from XLD to region
 *****************************************************************************/

  // Create a filled region from an XLD contour
  HRegion(const HXLDCont& xld);

  // Create a filled region from an XLD polygon
  HRegion(const HXLDPoly& xld);


/*****************************************************************************
 * Operator overloads (non-member overloads reside in HOperatorOverloads.h)
 *****************************************************************************/

  // Complement (not necessarily finite!)
  HRegion operator ! () const;

  // Negate the region
  HRegion operator - () const;

  // Convert region to xld representing the region border
  operator HXLDCont() const;


/*****************************************************************************
 * Non-generic convenience members
 *****************************************************************************/

  // The area of the region
  HTuple Area();

  // The center row of the region
  HTuple Row();

  // The center column of the region
  HTuple Column();


  /***************************************************************************
   * Operators                                                               *
   ***************************************************************************/

  // Generate XLD contours from regions.
  HXLDCont GenContourRegionXld(const HString& Mode) const;

  // Generate XLD contours from regions.
  HXLDCont GenContourRegionXld(const char* Mode) const;

#ifdef _WIN32
  // Generate XLD contours from regions.
  HXLDCont GenContourRegionXld(const wchar_t* Mode) const;
#endif

  // Convert a skeleton into XLD contours.
  HXLDCont GenContoursSkeletonXld(Hlong Length, const HString& Mode) const;

  // Convert a skeleton into XLD contours.
  HXLDCont GenContoursSkeletonXld(Hlong Length, const char* Mode) const;

#ifdef _WIN32
  // Convert a skeleton into XLD contours.
  HXLDCont GenContoursSkeletonXld(Hlong Length, const wchar_t* Mode) const;
#endif

  // Receive regions over a socket connection.
  void ReceiveRegion(const HSocket& Socket);

  // Send regions over a socket connection.
  void SendRegion(const HSocket& Socket) const;

  // Create a model to perform 3D-measurements using the sheet-of-light technique.
  HSheetOfLightModel CreateSheetOfLightModel(const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Create a model to perform 3D-measurements using the sheet-of-light technique.
  HSheetOfLightModel CreateSheetOfLightModel(const HString& GenParamName, Hlong GenParamValue) const;

  // Create a model to perform 3D-measurements using the sheet-of-light technique.
  HSheetOfLightModel CreateSheetOfLightModel(const char* GenParamName, Hlong GenParamValue) const;

#ifdef _WIN32
  // Create a model to perform 3D-measurements using the sheet-of-light technique.
  HSheetOfLightModel CreateSheetOfLightModel(const wchar_t* GenParamName, Hlong GenParamValue) const;
#endif

  // Selects characters from a given region.
  HRegion SelectCharacters(const HString& DotPrint, const HString& StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, const HString& Punctuation, const HString& DiacriticMarks, const HString& PartitionMethod, const HString& PartitionLines, const HString& FragmentDistance, const HString& ConnectFragments, Hlong ClutterSizeMax, const HString& StopAfter) const;

  // Selects characters from a given region.
  HRegion SelectCharacters(const char* DotPrint, const char* StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, const char* Punctuation, const char* DiacriticMarks, const char* PartitionMethod, const char* PartitionLines, const char* FragmentDistance, const char* ConnectFragments, Hlong ClutterSizeMax, const char* StopAfter) const;

#ifdef _WIN32
  // Selects characters from a given region.
  HRegion SelectCharacters(const wchar_t* DotPrint, const wchar_t* StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, const wchar_t* Punctuation, const wchar_t* DiacriticMarks, const wchar_t* PartitionMethod, const wchar_t* PartitionLines, const wchar_t* FragmentDistance, const wchar_t* ConnectFragments, Hlong ClutterSizeMax, const wchar_t* StopAfter) const;
#endif

  // Segments characters in a given region of an image.
  HImage SegmentCharacters(const HImage& Image, HRegion* RegionForeground, const HString& Method, const HString& EliminateLines, const HString& DotPrint, const HString& StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, Hlong ThresholdOffset, Hlong Contrast, HTuple* UsedThreshold) const;

  // Segments characters in a given region of an image.
  HImage SegmentCharacters(const HImage& Image, HRegion* RegionForeground, const HString& Method, const HString& EliminateLines, const HString& DotPrint, const HString& StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, Hlong ThresholdOffset, Hlong Contrast, Hlong* UsedThreshold) const;

  // Segments characters in a given region of an image.
  HImage SegmentCharacters(const HImage& Image, HRegion* RegionForeground, const char* Method, const char* EliminateLines, const char* DotPrint, const char* StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, Hlong ThresholdOffset, Hlong Contrast, Hlong* UsedThreshold) const;

#ifdef _WIN32
  // Segments characters in a given region of an image.
  HImage SegmentCharacters(const HImage& Image, HRegion* RegionForeground, const wchar_t* Method, const wchar_t* EliminateLines, const wchar_t* DotPrint, const wchar_t* StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, Hlong ThresholdOffset, Hlong Contrast, Hlong* UsedThreshold) const;
#endif

  // Determines the slant of characters of a text line or paragraph.
  HTuple TextLineSlant(const HImage& Image, Hlong CharHeight, double SlantFrom, double SlantTo) const;

  // Determines the orientation of a text line or paragraph.
  HTuple TextLineOrientation(const HImage& Image, Hlong CharHeight, double OrientationFrom, double OrientationTo) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Background, const HImage& Image, const HString& Metric, const HTuple& Distance, const HTuple& MinNumberPercent, HTuple* Center, double* Quality) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Background, const HImage& Image, const HString& Metric, double Distance, double MinNumberPercent, HTuple* Center, double* Quality) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Background, const HImage& Image, const char* Metric, double Distance, double MinNumberPercent, HTuple* Center, double* Quality) const;

#ifdef _WIN32
  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Background, const HImage& Image, const wchar_t* Metric, double Distance, double MinNumberPercent, HTuple* Center, double* Quality) const;
#endif

  // Train a classificator using a multi-channel image.
  void LearnNdimBox(const HRegion& Background, const HImage& MultiChannelImage, const HClassBox& ClassifHandle) const;

  // Transform a region in polar coordinates back to cartesian coordinates.
  HRegion PolarTransRegionInv(const HTuple& Row, const HTuple& Column, double AngleStart, double AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, Hlong WidthIn, Hlong HeightIn, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform a region in polar coordinates back to cartesian coordinates.
  HRegion PolarTransRegionInv(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong WidthIn, Hlong HeightIn, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform a region in polar coordinates back to cartesian coordinates.
  HRegion PolarTransRegionInv(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong WidthIn, Hlong HeightIn, Hlong Width, Hlong Height, const char* Interpolation) const;

#ifdef _WIN32
  // Transform a region in polar coordinates back to cartesian coordinates.
  HRegion PolarTransRegionInv(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong WidthIn, Hlong HeightIn, Hlong Width, Hlong Height, const wchar_t* Interpolation) const;
#endif

  // Transform a region within an annular arc to polar coordinates.
  HRegion PolarTransRegion(const HTuple& Row, const HTuple& Column, double AngleStart, double AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform a region within an annular arc to polar coordinates.
  HRegion PolarTransRegion(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform a region within an annular arc to polar coordinates.
  HRegion PolarTransRegion(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const char* Interpolation) const;

#ifdef _WIN32
  // Transform a region within an annular arc to polar coordinates.
  HRegion PolarTransRegion(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const wchar_t* Interpolation) const;
#endif

  // Merge regions from line scan images.
  HRegion MergeRegionsLineScan(const HRegion& PrevRegions, HRegion* PrevMergedRegions, Hlong ImageHeight, const HString& MergeBorder, Hlong MaxImagesRegion) const;

  // Merge regions from line scan images.
  HRegion MergeRegionsLineScan(const HRegion& PrevRegions, HRegion* PrevMergedRegions, Hlong ImageHeight, const char* MergeBorder, Hlong MaxImagesRegion) const;

#ifdef _WIN32
  // Merge regions from line scan images.
  HRegion MergeRegionsLineScan(const HRegion& PrevRegions, HRegion* PrevMergedRegions, Hlong ImageHeight, const wchar_t* MergeBorder, Hlong MaxImagesRegion) const;
#endif

  // Partition a region into rectangles of approximately equal size.
  HRegion PartitionRectangle(double Width, double Height) const;

  // Partition a region horizontally at positions of small vertical extent.
  HRegion PartitionDynamic(double Distance, double Percent) const;

  // Convert regions to a label image.
  HImage RegionToLabel(const HString& Type, Hlong Width, Hlong Height) const;

  // Convert regions to a label image.
  HImage RegionToLabel(const char* Type, Hlong Width, Hlong Height) const;

#ifdef _WIN32
  // Convert regions to a label image.
  HImage RegionToLabel(const wchar_t* Type, Hlong Width, Hlong Height) const;
#endif

  // Convert a region into a binary byte-image.
  HImage RegionToBin(Hlong ForegroundGray, Hlong BackgroundGray, Hlong Width, Hlong Height) const;

  // Return the union of two regions.
  HRegion Union2(const HRegion& Region2) const;

  // Return the union of all input regions.
  HRegion Union1() const;

  // Compute the closest-point transformation of a region.
  HImage ClosestPointTransform(HImage* ClosestPoints, const HString& Metric, const HString& Foreground, const HString& ClosestPointMode, Hlong Width, Hlong Height) const;

  // Compute the closest-point transformation of a region.
  HImage ClosestPointTransform(HImage* ClosestPoints, const char* Metric, const char* Foreground, const char* ClosestPointMode, Hlong Width, Hlong Height) const;

#ifdef _WIN32
  // Compute the closest-point transformation of a region.
  HImage ClosestPointTransform(HImage* ClosestPoints, const wchar_t* Metric, const wchar_t* Foreground, const wchar_t* ClosestPointMode, Hlong Width, Hlong Height) const;
#endif

  // Compute the distance transformation of a region.
  HImage DistanceTransform(const HString& Metric, const HString& Foreground, Hlong Width, Hlong Height) const;

  // Compute the distance transformation of a region.
  HImage DistanceTransform(const char* Metric, const char* Foreground, Hlong Width, Hlong Height) const;

#ifdef _WIN32
  // Compute the distance transformation of a region.
  HImage DistanceTransform(const wchar_t* Metric, const wchar_t* Foreground, Hlong Width, Hlong Height) const;
#endif

  // Compute the skeleton of a region.
  HRegion Skeleton() const;

  // Apply a projective transformation to a region.
  HRegion ProjectiveTransRegion(const HHomMat2D& HomMat2D, const HString& Interpolation) const;

  // Apply a projective transformation to a region.
  HRegion ProjectiveTransRegion(const HHomMat2D& HomMat2D, const char* Interpolation) const;

#ifdef _WIN32
  // Apply a projective transformation to a region.
  HRegion ProjectiveTransRegion(const HHomMat2D& HomMat2D, const wchar_t* Interpolation) const;
#endif

  // Apply an arbitrary affine 2D transformation to regions.
  HRegion AffineTransRegion(const HHomMat2D& HomMat2D, const HString& Interpolate) const;

  // Apply an arbitrary affine 2D transformation to regions.
  HRegion AffineTransRegion(const HHomMat2D& HomMat2D, const char* Interpolate) const;

#ifdef _WIN32
  // Apply an arbitrary affine 2D transformation to regions.
  HRegion AffineTransRegion(const HHomMat2D& HomMat2D, const wchar_t* Interpolate) const;
#endif

  // Reflect a region about an axis.
  HRegion MirrorRegion(const HString& Mode, Hlong WidthHeight) const;

  // Reflect a region about an axis.
  HRegion MirrorRegion(const char* Mode, Hlong WidthHeight) const;

#ifdef _WIN32
  // Reflect a region about an axis.
  HRegion MirrorRegion(const wchar_t* Mode, Hlong WidthHeight) const;
#endif

  // Zoom a region.
  HRegion ZoomRegion(double ScaleWidth, double ScaleHeight) const;

  // Translate a region.
  HRegion MoveRegion(Hlong Row, Hlong Column) const;

  // Find junctions and end points in a skeleton.
  HRegion JunctionsSkeleton(HRegion* JuncPoints) const;

  // Calculate the intersection of two regions.
  HRegion Intersection(const HRegion& Region2) const;

  // Partition the image plane using given regions.
  HRegion Interjacent(const HString& Mode) const;

  // Partition the image plane using given regions.
  HRegion Interjacent(const char* Mode) const;

#ifdef _WIN32
  // Partition the image plane using given regions.
  HRegion Interjacent(const wchar_t* Mode) const;
#endif

  // Fill up holes in regions.
  HRegion FillUp() const;

  // Fill up holes in regions having given shape features.
  HRegion FillUpShape(const HString& Feature, const HTuple& Min, const HTuple& Max) const;

  // Fill up holes in regions having given shape features.
  HRegion FillUpShape(const HString& Feature, double Min, double Max) const;

  // Fill up holes in regions having given shape features.
  HRegion FillUpShape(const char* Feature, double Min, double Max) const;

#ifdef _WIN32
  // Fill up holes in regions having given shape features.
  HRegion FillUpShape(const wchar_t* Feature, double Min, double Max) const;
#endif

  // Fill gaps between regions or split overlapping regions.
  HRegion ExpandRegion(const HRegion& ForbiddenArea, const HTuple& Iterations, const HString& Mode) const;

  // Fill gaps between regions or split overlapping regions.
  HRegion ExpandRegion(const HRegion& ForbiddenArea, Hlong Iterations, const HString& Mode) const;

  // Fill gaps between regions or split overlapping regions.
  HRegion ExpandRegion(const HRegion& ForbiddenArea, Hlong Iterations, const char* Mode) const;

#ifdef _WIN32
  // Fill gaps between regions or split overlapping regions.
  HRegion ExpandRegion(const HRegion& ForbiddenArea, Hlong Iterations, const wchar_t* Mode) const;
#endif

  // Clip a region relative to its smallest surrounding rectangle.
  HRegion ClipRegionRel(Hlong Top, Hlong Bottom, Hlong Left, Hlong Right) const;

  // Clip a region to a rectangle.
  HRegion ClipRegion(Hlong Row1, Hlong Column1, Hlong Row2, Hlong Column2) const;

  // Rank operator for regions.
  HRegion RankRegion(Hlong Width, Hlong Height, Hlong Number) const;

  // Compute connected components of a region.
  HRegion Connection() const;

  // Calculate the symmetric difference of two regions.
  HRegion SymmDifference(const HRegion& Region2) const;

  // Calculate the difference of two regions.
  HRegion Difference(const HRegion& Sub) const;

  // Return the complement of a region.
  HRegion Complement() const;

  // Determine the connected components of the background of given regions.
  HRegion BackgroundSeg() const;

  // Generate a region having a given Hamming distance.
  HRegion HammingChangeRegion(Hlong Width, Hlong Height, Hlong Distance) const;

  // Remove noise from a region.
  HRegion RemoveNoiseRegion(const HString& Type) const;

  // Remove noise from a region.
  HRegion RemoveNoiseRegion(const char* Type) const;

#ifdef _WIN32
  // Remove noise from a region.
  HRegion RemoveNoiseRegion(const wchar_t* Type) const;
#endif

  // Transform the shape of a region.
  HRegion ShapeTrans(const HString& Type) const;

  // Transform the shape of a region.
  HRegion ShapeTrans(const char* Type) const;

#ifdef _WIN32
  // Transform the shape of a region.
  HRegion ShapeTrans(const wchar_t* Type) const;
#endif

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HImage& Image, const HRegion& ForbiddenArea, const HTuple& Iterations, const HString& Mode, const HTuple& Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HImage& Image, const HRegion& ForbiddenArea, const HString& Iterations, const HString& Mode, Hlong Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HImage& Image, const HRegion& ForbiddenArea, const char* Iterations, const char* Mode, Hlong Threshold) const;

#ifdef _WIN32
  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HImage& Image, const HRegion& ForbiddenArea, const wchar_t* Iterations, const wchar_t* Mode, Hlong Threshold) const;
#endif

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HImage& Image, const HRegion& ForbiddenArea, const HTuple& Iterations, const HString& Mode, const HTuple& RefGray, const HTuple& Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HImage& Image, const HRegion& ForbiddenArea, const HString& Iterations, const HString& Mode, Hlong RefGray, Hlong Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HImage& Image, const HRegion& ForbiddenArea, const char* Iterations, const char* Mode, Hlong RefGray, Hlong Threshold) const;

#ifdef _WIN32
  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HImage& Image, const HRegion& ForbiddenArea, const wchar_t* Iterations, const wchar_t* Mode, Hlong RefGray, Hlong Threshold) const;
#endif

  // Split lines represented by one pixel wide, non-branching lines.
  void SplitSkeletonLines(Hlong MaxDistance, HTuple* BeginRow, HTuple* BeginCol, HTuple* EndRow, HTuple* EndCol) const;

  // Split lines represented by one pixel wide, non-branching regions.
  HRegion SplitSkeletonRegion(Hlong MaxDistance) const;

  // Convert a histogram into a region.
  void GenRegionHisto(const HTuple& Histogram, Hlong Row, Hlong Column, Hlong Scale);

  // Eliminate runs of a given length.
  HRegion EliminateRuns(Hlong ElimShorter, Hlong ElimLonger) const;

  // Calculate the difference of two object tuples.
  HRegion ObjDiff(const HRegion& ObjectsSub) const;

  // Paint regions into an image.
  HImage PaintRegion(const HImage& Image, const HTuple& Grayval, const HString& Type) const;

  // Paint regions into an image.
  HImage PaintRegion(const HImage& Image, double Grayval, const HString& Type) const;

  // Paint regions into an image.
  HImage PaintRegion(const HImage& Image, double Grayval, const char* Type) const;

#ifdef _WIN32
  // Paint regions into an image.
  HImage PaintRegion(const HImage& Image, double Grayval, const wchar_t* Type) const;
#endif

  // Overpaint regions in an image.
  void OverpaintRegion(const HImage& Image, const HTuple& Grayval, const HString& Type) const;

  // Overpaint regions in an image.
  void OverpaintRegion(const HImage& Image, double Grayval, const HString& Type) const;

  // Overpaint regions in an image.
  void OverpaintRegion(const HImage& Image, double Grayval, const char* Type) const;

#ifdef _WIN32
  // Overpaint regions in an image.
  void OverpaintRegion(const HImage& Image, double Grayval, const wchar_t* Type) const;
#endif

  // Copy an iconic object in the HALCON database.
  HRegion CopyObj(Hlong Index, Hlong NumObj) const;

  // Concatenate two iconic object tuples.
  HRegion ConcatObj(const HRegion& Objects2) const;

  // Select objects from an object tuple.
  HRegion SelectObj(const HTuple& Index) const;

  // Select objects from an object tuple.
  HRegion SelectObj(Hlong Index) const;

  // Compare iconic objects regarding equality.
  Hlong CompareObj(const HRegion& Objects2, const HTuple& Epsilon) const;

  // Compare iconic objects regarding equality.
  Hlong CompareObj(const HRegion& Objects2, double Epsilon) const;

  // Test whether a region is contained in another region.
  HTuple TestSubsetRegion(const HRegion& Region2) const;

  // Test whether the regions of two objects are identical.
  Hlong TestEqualRegion(const HRegion& Regions2) const;

  // Compare image objects regarding equality.
  Hlong TestEqualObj(const HRegion& Objects2) const;

  // Store a polygon as a "filled" region.
  void GenRegionPolygonFilled(const HTuple& Rows, const HTuple& Columns);

  // Store a polygon as a region.
  void GenRegionPolygon(const HTuple& Rows, const HTuple& Columns);

  // Store individual pixels as image region.
  void GenRegionPoints(const HTuple& Rows, const HTuple& Columns);

  // Store individual pixels as image region.
  void GenRegionPoints(Hlong Rows, Hlong Columns);

  // Create a region from a runlength coding.
  void GenRegionRuns(const HTuple& Row, const HTuple& ColumnBegin, const HTuple& ColumnEnd);

  // Create a region from a runlength coding.
  void GenRegionRuns(Hlong Row, Hlong ColumnBegin, Hlong ColumnEnd);

  // Create a rectangle of any orientation.
  void GenRectangle2(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2);

  // Create a rectangle of any orientation.
  void GenRectangle2(double Row, double Column, double Phi, double Length1, double Length2);

  // Create a rectangle parallel to the coordinate axes.
  void GenRectangle1(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

  // Create a rectangle parallel to the coordinate axes.
  void GenRectangle1(double Row1, double Column1, double Row2, double Column2);

  // Create a random region.
  void GenRandomRegion(Hlong Width, Hlong Height);

  // Create an ellipse sector.
  void GenEllipseSector(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& StartAngle, const HTuple& EndAngle);

  // Create an ellipse sector.
  void GenEllipseSector(double Row, double Column, double Phi, double Radius1, double Radius2, double StartAngle, double EndAngle);

  // Create an ellipse.
  void GenEllipse(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2);

  // Create an ellipse.
  void GenEllipse(double Row, double Column, double Phi, double Radius1, double Radius2);

  // Create a circle sector.
  void GenCircleSector(const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& StartAngle, const HTuple& EndAngle);

  // Create a circle sector.
  void GenCircleSector(double Row, double Column, double Radius, double StartAngle, double EndAngle);

  // Create a circle.
  void GenCircle(const HTuple& Row, const HTuple& Column, const HTuple& Radius);

  // Create a circle.
  void GenCircle(double Row, double Column, double Radius);

  // Create a checkered region.
  void GenCheckerRegion(Hlong WidthRegion, Hlong HeightRegion, Hlong WidthPattern, Hlong HeightPattern);

  // Create a region from lines or pixels.
  void GenGridRegion(const HTuple& RowSteps, const HTuple& ColumnSteps, const HString& Type, Hlong Width, Hlong Height);

  // Create a region from lines or pixels.
  void GenGridRegion(Hlong RowSteps, Hlong ColumnSteps, const HString& Type, Hlong Width, Hlong Height);

  // Create a region from lines or pixels.
  void GenGridRegion(Hlong RowSteps, Hlong ColumnSteps, const char* Type, Hlong Width, Hlong Height);

#ifdef _WIN32
  // Create a region from lines or pixels.
  void GenGridRegion(Hlong RowSteps, Hlong ColumnSteps, const wchar_t* Type, Hlong Width, Hlong Height);
#endif

  // Create random regions like circles, rectangles and ellipses.
  void GenRandomRegions(const HString& Type, const HTuple& WidthMin, const HTuple& WidthMax, const HTuple& HeightMin, const HTuple& HeightMax, const HTuple& PhiMin, const HTuple& PhiMax, Hlong NumRegions, Hlong Width, Hlong Height);

  // Create random regions like circles, rectangles and ellipses.
  void GenRandomRegions(const HString& Type, double WidthMin, double WidthMax, double HeightMin, double HeightMax, double PhiMin, double PhiMax, Hlong NumRegions, Hlong Width, Hlong Height);

  // Create random regions like circles, rectangles and ellipses.
  void GenRandomRegions(const char* Type, double WidthMin, double WidthMax, double HeightMin, double HeightMax, double PhiMin, double PhiMax, Hlong NumRegions, Hlong Width, Hlong Height);

#ifdef _WIN32
  // Create random regions like circles, rectangles and ellipses.
  void GenRandomRegions(const wchar_t* Type, double WidthMin, double WidthMax, double HeightMin, double HeightMax, double PhiMin, double PhiMax, Hlong NumRegions, Hlong Width, Hlong Height);
#endif

  // Store input lines described in Hesse normal form as regions.
  void GenRegionHline(const HTuple& Orientation, const HTuple& Distance);

  // Store input lines described in Hesse normal form as regions.
  void GenRegionHline(double Orientation, double Distance);

  // Store input lines as regions.
  void GenRegionLine(const HTuple& BeginRow, const HTuple& BeginCol, const HTuple& EndRow, const HTuple& EndCol);

  // Store input lines as regions.
  void GenRegionLine(Hlong BeginRow, Hlong BeginCol, Hlong EndRow, Hlong EndCol);

  // Create an empty region.
  void GenEmptyRegion();

  // Access the thickness of a region along the main axis.
  HTuple GetRegionThickness(HTuple* Histogramm) const;

  // Polygon approximation of a region.
  void GetRegionPolygon(const HTuple& Tolerance, HTuple* Rows, HTuple* Columns) const;

  // Polygon approximation of a region.
  void GetRegionPolygon(double Tolerance, HTuple* Rows, HTuple* Columns) const;

  // Access the pixels of a region.
  void GetRegionPoints(HTuple* Rows, HTuple* Columns) const;

  // Access the contour of an object.
  void GetRegionContour(HTuple* Rows, HTuple* Columns) const;

  // Access the runlength coding of a region.
  void GetRegionRuns(HTuple* Row, HTuple* ColumnBegin, HTuple* ColumnEnd) const;

  // Contour of an object as chain code.
  void GetRegionChain(Hlong* Row, Hlong* Column, HTuple* Chain) const;

  // Access convex hull as contour.
  void GetRegionConvex(HTuple* Rows, HTuple* Columns) const;

  // Classify a related group of characters with an OCR classifier.
  HTuple DoOcrWordKnn(const HImage& Image, const HOCRKnn& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, HTuple* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordKnn(const HImage& Image, const HOCRKnn& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordKnn(const HImage& Image, const HOCRKnn& OCRHandle, const char* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

#ifdef _WIN32
  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordKnn(const HImage& Image, const HOCRKnn& OCRHandle, const wchar_t* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;
#endif

  // Classify multiple characters with an k-NN classifier.
  HTuple DoOcrMultiClassKnn(const HImage& Image, const HOCRKnn& OCRHandle, HTuple* Confidence) const;

  // Classify multiple characters with an k-NN classifier.
  HString DoOcrMultiClassKnn(const HImage& Image, const HOCRKnn& OCRHandle, double* Confidence) const;

  // Classify a single character with an OCR classifier.
  HTuple DoOcrSingleClassKnn(const HImage& Image, const HOCRKnn& OCRHandle, const HTuple& NumClasses, const HTuple& NumNeighbors, HTuple* Confidence) const;

  // Classify a single character with an OCR classifier.
  HString DoOcrSingleClassKnn(const HImage& Image, const HOCRKnn& OCRHandle, const HTuple& NumClasses, const HTuple& NumNeighbors, double* Confidence) const;

  // Classify a related group of characters with an OCR classifier.
  HTuple DoOcrWordSvm(const HImage& Image, const HOCRSvm& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, HString* Word, double* Score) const;

  // Classify a related group of characters with an OCR classifier.
  HTuple DoOcrWordSvm(const HImage& Image, const HOCRSvm& OCRHandle, const char* Expression, Hlong NumAlternatives, Hlong NumCorrections, HString* Word, double* Score) const;

#ifdef _WIN32
  // Classify a related group of characters with an OCR classifier.
  HTuple DoOcrWordSvm(const HImage& Image, const HOCRSvm& OCRHandle, const wchar_t* Expression, Hlong NumAlternatives, Hlong NumCorrections, HString* Word, double* Score) const;
#endif

  // Classify multiple characters with an SVM-based OCR classifier.
  HTuple DoOcrMultiClassSvm(const HImage& Image, const HOCRSvm& OCRHandle) const;

  // Classify a single character with an SVM-based OCR classifier.
  HTuple DoOcrSingleClassSvm(const HImage& Image, const HOCRSvm& OCRHandle, const HTuple& Num) const;

  // Classify a related group of characters with an OCR classifier.
  HTuple DoOcrWordMlp(const HImage& Image, const HOCRMlp& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, HTuple* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordMlp(const HImage& Image, const HOCRMlp& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordMlp(const HImage& Image, const HOCRMlp& OCRHandle, const char* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

#ifdef _WIN32
  // Classify a related group of characters with an OCR classifier.
  HString DoOcrWordMlp(const HImage& Image, const HOCRMlp& OCRHandle, const wchar_t* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;
#endif

  // Classify multiple characters with an OCR classifier.
  HTuple DoOcrMultiClassMlp(const HImage& Image, const HOCRMlp& OCRHandle, HTuple* Confidence) const;

  // Classify multiple characters with an OCR classifier.
  HString DoOcrMultiClassMlp(const HImage& Image, const HOCRMlp& OCRHandle, double* Confidence) const;

  // Classify a single character with an OCR classifier.
  HTuple DoOcrSingleClassMlp(const HImage& Image, const HOCRMlp& OCRHandle, const HTuple& Num, HTuple* Confidence) const;

  // Classify a single character with an OCR classifier.
  HString DoOcrSingleClassMlp(const HImage& Image, const HOCRMlp& OCRHandle, const HTuple& Num, double* Confidence) const;

  // Classify one character.
  HTuple DoOcrSingle(const HImage& Image, const HOCRBox& OcrHandle, HTuple* Confidences) const;

  // Classify characters.
  HTuple DoOcrMulti(const HImage& Image, const HOCRBox& OcrHandle, HTuple* Confidence) const;

  // Classify characters.
  HString DoOcrMulti(const HImage& Image, const HOCRBox& OcrHandle, double* Confidence) const;

  // Train an OCR classifier by the input of regions.
  double TraindOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const HTuple& Class) const;

  // Train an OCR classifier by the input of regions.
  double TraindOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const HString& Class) const;

  // Train an OCR classifier by the input of regions.
  double TraindOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const char* Class) const;

#ifdef _WIN32
  // Train an OCR classifier by the input of regions.
  double TraindOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const wchar_t* Class) const;
#endif

  // Protection of training data.
  static void ProtectOcrTrainf(const HString& TrainingFile, const HTuple& Password, const HString& TrainingFileProtected);

  // Protection of training data.
  static void ProtectOcrTrainf(const HString& TrainingFile, const HString& Password, const HString& TrainingFileProtected);

  // Protection of training data.
  static void ProtectOcrTrainf(const char* TrainingFile, const char* Password, const char* TrainingFileProtected);

#ifdef _WIN32
  // Protection of training data.
  static void ProtectOcrTrainf(const wchar_t* TrainingFile, const wchar_t* Password, const wchar_t* TrainingFileProtected);
#endif

  // Storing of training characters into a file.
  void WriteOcrTrainf(const HImage& Image, const HTuple& Class, const HString& TrainingFile) const;

  // Storing of training characters into a file.
  void WriteOcrTrainf(const HImage& Image, const HString& Class, const HString& TrainingFile) const;

  // Storing of training characters into a file.
  void WriteOcrTrainf(const HImage& Image, const char* Class, const char* TrainingFile) const;

#ifdef _WIN32
  // Storing of training characters into a file.
  void WriteOcrTrainf(const HImage& Image, const wchar_t* Class, const wchar_t* TrainingFile) const;
#endif

  // Sorting of regions with respect to their relative position.
  HRegion SortRegion(const HString& SortMode, const HString& Order, const HString& RowOrCol) const;

  // Sorting of regions with respect to their relative position.
  HRegion SortRegion(const char* SortMode, const char* Order, const char* RowOrCol) const;

#ifdef _WIN32
  // Sorting of regions with respect to their relative position.
  HRegion SortRegion(const wchar_t* SortMode, const wchar_t* Order, const wchar_t* RowOrCol) const;
#endif

  // Test an OCR classifier.
  HTuple TestdOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const HTuple& Class) const;

  // Test an OCR classifier.
  double TestdOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const HString& Class) const;

  // Test an OCR classifier.
  double TestdOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const char* Class) const;

#ifdef _WIN32
  // Test an OCR classifier.
  double TestdOcrClassBox(const HImage& Image, const HOCRBox& OcrHandle, const wchar_t* Class) const;
#endif

  // Add characters to a training file.
  void AppendOcrTrainf(const HImage& Image, const HTuple& Class, const HString& TrainingFile) const;

  // Add characters to a training file.
  void AppendOcrTrainf(const HImage& Image, const HString& Class, const HString& TrainingFile) const;

  // Add characters to a training file.
  void AppendOcrTrainf(const HImage& Image, const char* Class, const char* TrainingFile) const;

#ifdef _WIN32
  // Add characters to a training file.
  void AppendOcrTrainf(const HImage& Image, const wchar_t* Class, const wchar_t* TrainingFile) const;
#endif

  // Prune the branches of a region.
  HRegion Pruning(Hlong Length) const;

  // Reduce a region to its boundary.
  HRegion Boundary(const HString& BoundaryType) const;

  // Reduce a region to its boundary.
  HRegion Boundary(const char* BoundaryType) const;

#ifdef _WIN32
  // Reduce a region to its boundary.
  HRegion Boundary(const wchar_t* BoundaryType) const;
#endif

  // Perform a closing after an opening with multiple structuring elements.
  HRegion Fitting(const HRegion& StructElements) const;

  // Generate standard structuring elements.
  void GenStructElements(const HString& Type, Hlong Row, Hlong Column);

  // Generate standard structuring elements.
  void GenStructElements(const char* Type, Hlong Row, Hlong Column);

#ifdef _WIN32
  // Generate standard structuring elements.
  void GenStructElements(const wchar_t* Type, Hlong Row, Hlong Column);
#endif

  // Reflect a region about a point.
  HRegion TransposeRegion(Hlong Row, Hlong Column) const;

  // Remove the result of a hit-or-miss operation from a region (sequential).
  HRegion ThinningSeq(const HString& GolayElement, const HTuple& Iterations) const;

  // Remove the result of a hit-or-miss operation from a region (sequential).
  HRegion ThinningSeq(const HString& GolayElement, Hlong Iterations) const;

  // Remove the result of a hit-or-miss operation from a region (sequential).
  HRegion ThinningSeq(const char* GolayElement, Hlong Iterations) const;

#ifdef _WIN32
  // Remove the result of a hit-or-miss operation from a region (sequential).
  HRegion ThinningSeq(const wchar_t* GolayElement, Hlong Iterations) const;
#endif

  // Remove the result of a hit-or-miss operation from a region (using a Golay structuring element).
  HRegion ThinningGolay(const HString& GolayElement, Hlong Rotation) const;

  // Remove the result of a hit-or-miss operation from a region (using a Golay structuring element).
  HRegion ThinningGolay(const char* GolayElement, Hlong Rotation) const;

#ifdef _WIN32
  // Remove the result of a hit-or-miss operation from a region (using a Golay structuring element).
  HRegion ThinningGolay(const wchar_t* GolayElement, Hlong Rotation) const;
#endif

  // Remove the result of a hit-or-miss operation from a region.
  HRegion Thinning(const HRegion& StructElement1, const HRegion& StructElement2, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Add the result of a hit-or-miss operation to a region (sequential).
  HRegion ThickeningSeq(const HString& GolayElement, Hlong Iterations) const;

  // Add the result of a hit-or-miss operation to a region (sequential).
  HRegion ThickeningSeq(const char* GolayElement, Hlong Iterations) const;

#ifdef _WIN32
  // Add the result of a hit-or-miss operation to a region (sequential).
  HRegion ThickeningSeq(const wchar_t* GolayElement, Hlong Iterations) const;
#endif

  // Add the result of a hit-or-miss operation to a region (using a Golay structuring element).
  HRegion ThickeningGolay(const HString& GolayElement, Hlong Rotation) const;

  // Add the result of a hit-or-miss operation to a region (using a Golay structuring element).
  HRegion ThickeningGolay(const char* GolayElement, Hlong Rotation) const;

#ifdef _WIN32
  // Add the result of a hit-or-miss operation to a region (using a Golay structuring element).
  HRegion ThickeningGolay(const wchar_t* GolayElement, Hlong Rotation) const;
#endif

  // Add the result of a hit-or-miss operation to a region.
  HRegion Thickening(const HRegion& StructElement1, const HRegion& StructElement2, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Hit-or-miss operation for regions using the Golay alphabet (sequential).
  HRegion HitOrMissSeq(const HString& GolayElement) const;

  // Hit-or-miss operation for regions using the Golay alphabet (sequential).
  HRegion HitOrMissSeq(const char* GolayElement) const;

#ifdef _WIN32
  // Hit-or-miss operation for regions using the Golay alphabet (sequential).
  HRegion HitOrMissSeq(const wchar_t* GolayElement) const;
#endif

  // Hit-or-miss operation for regions using the Golay alphabet.
  HRegion HitOrMissGolay(const HString& GolayElement, Hlong Rotation) const;

  // Hit-or-miss operation for regions using the Golay alphabet.
  HRegion HitOrMissGolay(const char* GolayElement, Hlong Rotation) const;

#ifdef _WIN32
  // Hit-or-miss operation for regions using the Golay alphabet.
  HRegion HitOrMissGolay(const wchar_t* GolayElement, Hlong Rotation) const;
#endif

  // Hit-or-miss operation for regions.
  HRegion HitOrMiss(const HRegion& StructElement1, const HRegion& StructElement2, Hlong Row, Hlong Column) const;

  // Generate the structuring elements of the Golay alphabet.
  HRegion GolayElements(const HString& GolayElement, Hlong Rotation, Hlong Row, Hlong Column);

  // Generate the structuring elements of the Golay alphabet.
  HRegion GolayElements(const char* GolayElement, Hlong Rotation, Hlong Row, Hlong Column);

#ifdef _WIN32
  // Generate the structuring elements of the Golay alphabet.
  HRegion GolayElements(const wchar_t* GolayElement, Hlong Rotation, Hlong Row, Hlong Column);
#endif

  // Thinning of a region.
  HRegion MorphSkiz(const HTuple& Iterations1, const HTuple& Iterations2) const;

  // Thinning of a region.
  HRegion MorphSkiz(Hlong Iterations1, Hlong Iterations2) const;

  // Compute the morphological skeleton of a region.
  HRegion MorphSkeleton() const;

  // Compute the union of bottom_hat and top_hat.
  HRegion MorphHat(const HRegion& StructElement) const;

  // Compute the bottom hat of regions.
  HRegion BottomHat(const HRegion& StructElement) const;

  // Compute the top hat of regions.
  HRegion TopHat(const HRegion& StructElement) const;

  // Erode a region (using a reference point).
  HRegion MinkowskiSub2(const HRegion& StructElement, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Erode a region.
  HRegion MinkowskiSub1(const HRegion& StructElement, Hlong Iterations) const;

  // Dilate a region (using a reference point).
  HRegion MinkowskiAdd2(const HRegion& StructElement, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Perform a Minkowski addition on a region.
  HRegion MinkowskiAdd1(const HRegion& StructElement, Hlong Iterations) const;

  // Close a region with a rectangular structuring element.
  HRegion ClosingRectangle1(Hlong Width, Hlong Height) const;

  // Close a region with an element from the Golay alphabet.
  HRegion ClosingGolay(const HString& GolayElement, Hlong Rotation) const;

  // Close a region with an element from the Golay alphabet.
  HRegion ClosingGolay(const char* GolayElement, Hlong Rotation) const;

#ifdef _WIN32
  // Close a region with an element from the Golay alphabet.
  HRegion ClosingGolay(const wchar_t* GolayElement, Hlong Rotation) const;
#endif

  // Close a region with a circular structuring element.
  HRegion ClosingCircle(const HTuple& Radius) const;

  // Close a region with a circular structuring element.
  HRegion ClosingCircle(double Radius) const;

  // Close a region.
  HRegion Closing(const HRegion& StructElement) const;

  // Separate overlapping regions.
  HRegion OpeningSeg(const HRegion& StructElement) const;

  // Open a region with an element from the Golay alphabet.
  HRegion OpeningGolay(const HString& GolayElement, Hlong Rotation) const;

  // Open a region with an element from the Golay alphabet.
  HRegion OpeningGolay(const char* GolayElement, Hlong Rotation) const;

#ifdef _WIN32
  // Open a region with an element from the Golay alphabet.
  HRegion OpeningGolay(const wchar_t* GolayElement, Hlong Rotation) const;
#endif

  // Open a region with a rectangular structuring element.
  HRegion OpeningRectangle1(Hlong Width, Hlong Height) const;

  // Open a region with a circular structuring element.
  HRegion OpeningCircle(const HTuple& Radius) const;

  // Open a region with a circular structuring element.
  HRegion OpeningCircle(double Radius) const;

  // Open a region.
  HRegion Opening(const HRegion& StructElement) const;

  // Erode a region sequentially.
  HRegion ErosionSeq(const HString& GolayElement, Hlong Iterations) const;

  // Erode a region sequentially.
  HRegion ErosionSeq(const char* GolayElement, Hlong Iterations) const;

#ifdef _WIN32
  // Erode a region sequentially.
  HRegion ErosionSeq(const wchar_t* GolayElement, Hlong Iterations) const;
#endif

  // Erode a region with an element from the Golay alphabet.
  HRegion ErosionGolay(const HString& GolayElement, Hlong Iterations, Hlong Rotation) const;

  // Erode a region with an element from the Golay alphabet.
  HRegion ErosionGolay(const char* GolayElement, Hlong Iterations, Hlong Rotation) const;

#ifdef _WIN32
  // Erode a region with an element from the Golay alphabet.
  HRegion ErosionGolay(const wchar_t* GolayElement, Hlong Iterations, Hlong Rotation) const;
#endif

  // Erode a region with a rectangular structuring element.
  HRegion ErosionRectangle1(Hlong Width, Hlong Height) const;

  // Erode a region with a circular structuring element.
  HRegion ErosionCircle(const HTuple& Radius) const;

  // Erode a region with a circular structuring element.
  HRegion ErosionCircle(double Radius) const;

  // Erode a region (using a reference point).
  HRegion Erosion2(const HRegion& StructElement, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Erode a region.
  HRegion Erosion1(const HRegion& StructElement, Hlong Iterations) const;

  // Dilate a region sequentially.
  HRegion DilationSeq(const HString& GolayElement, Hlong Iterations) const;

  // Dilate a region sequentially.
  HRegion DilationSeq(const char* GolayElement, Hlong Iterations) const;

#ifdef _WIN32
  // Dilate a region sequentially.
  HRegion DilationSeq(const wchar_t* GolayElement, Hlong Iterations) const;
#endif

  // Dilate a region with an element from the Golay alphabet.
  HRegion DilationGolay(const HString& GolayElement, Hlong Iterations, Hlong Rotation) const;

  // Dilate a region with an element from the Golay alphabet.
  HRegion DilationGolay(const char* GolayElement, Hlong Iterations, Hlong Rotation) const;

#ifdef _WIN32
  // Dilate a region with an element from the Golay alphabet.
  HRegion DilationGolay(const wchar_t* GolayElement, Hlong Iterations, Hlong Rotation) const;
#endif

  // Dilate a region with a rectangular structuring element.
  HRegion DilationRectangle1(Hlong Width, Hlong Height) const;

  // Dilate a region with a circular structuring element.
  HRegion DilationCircle(const HTuple& Radius) const;

  // Dilate a region with a circular structuring element.
  HRegion DilationCircle(double Radius) const;

  // Dilate a region (using a reference point).
  HRegion Dilation2(const HRegion& StructElement, Hlong Row, Hlong Column, Hlong Iterations) const;

  // Dilate a region.
  HRegion Dilation1(const HRegion& StructElement, Hlong Iterations) const;

  // Add gray values to regions.
  HImage AddChannels(const HImage& Image) const;

  // Centres of circles for a specific radius.
  HRegion HoughCircles(const HTuple& Radius, const HTuple& Percent, const HTuple& Mode) const;

  // Centres of circles for a specific radius.
  HRegion HoughCircles(Hlong Radius, Hlong Percent, Hlong Mode) const;

  // Return the Hough-Transform for circles with a given radius.
  HImage HoughCircleTrans(const HTuple& Radius) const;

  // Return the Hough-Transform for circles with a given radius.
  HImage HoughCircleTrans(Hlong Radius) const;

  // Detect lines in edge images with the help of the Hough transform and returns it in HNF.
  HTuple HoughLines(Hlong AngleResolution, Hlong Threshold, Hlong AngleGap, Hlong DistGap, HTuple* Dist) const;

  // Produce the Hough transform for lines within regions.
  HImage HoughLineTrans(Hlong AngleResolution) const;

  // Select those lines from a set of lines (in HNF) which fit best into a region.
  HRegion SelectMatchingLines(const HTuple& AngleIn, const HTuple& DistIn, Hlong LineWidth, Hlong Thresh, HTuple* AngleOut, HTuple* DistOut) const;

  // Select those lines from a set of lines (in HNF) which fit best into a region.
  HRegion SelectMatchingLines(double AngleIn, double DistIn, Hlong LineWidth, Hlong Thresh, double* AngleOut, double* DistOut) const;

  // Query the icon for region output
  void GetIcon(const HWindow& WindowHandle);

  // Icon definition for region output.
  void SetIcon(const HWindow& WindowHandle) const;

  // Displays regions in a window.
  void DispRegion(const HWindow& WindowHandle) const;

  // Interactive movement of a region with restriction of positions.
  HRegion DragRegion3(const HRegion& MaskRegion, const HWindow& WindowHandle, Hlong Row, Hlong Column) const;

  // Interactive movement of a region with fixpoint specification.
  HRegion DragRegion2(const HWindow& WindowHandle, Hlong Row, Hlong Column) const;

  // Interactive moving of a region.
  HRegion DragRegion1(const HWindow& WindowHandle) const;

  // Interactive drawing of a closed region.
  void DrawRegion(const HWindow& WindowHandle);

  // Interactive drawing of a polygon row.
  void DrawPolygon(const HWindow& WindowHandle);

  // Calculate the distance between a line segment and one region.
  void DistanceSr(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax) const;

  // Calculate the distance between a line segment and one region.
  void DistanceSr(double Row1, double Column1, double Row2, double Column2, double* DistanceMin, double* DistanceMax) const;

  // Calculate the distance between a line and a region.
  void DistanceLr(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax) const;

  // Calculate the distance between a line and a region.
  void DistanceLr(double Row1, double Column1, double Row2, double Column2, double* DistanceMin, double* DistanceMax) const;

  // Calculate the distance between a point and a region.
  void DistancePr(const HTuple& Row, const HTuple& Column, HTuple* DistanceMin, HTuple* DistanceMax) const;

  // Calculate the distance between a point and a region.
  void DistancePr(double Row, double Column, double* DistanceMin, double* DistanceMax) const;

  // Determine the noise distribution of an image.
  HTuple NoiseDistributionMean(const HImage& Image, Hlong FilterSize) const;

  // Determine the fuzzy entropy of regions.
  HTuple FuzzyEntropy(const HImage& Image, Hlong Apar, Hlong Cpar) const;

  // Calculate the fuzzy perimeter of a region.
  HTuple FuzzyPerimeter(const HImage& Image, Hlong Apar, Hlong Cpar) const;

  // Paint regions with their average gray value.
  HImage RegionToMean(const HImage& Image) const;

  // Close edge gaps using the edge amplitude image.
  HRegion CloseEdgesLength(const HImage& Gradient, Hlong MinAmplitude, Hlong MaxGapLength) const;

  // Close edge gaps using the edge amplitude image.
  HRegion CloseEdges(const HImage& EdgeImage, Hlong MinAmplitude) const;

  // Deserialize a serialized region.
  void DeserializeRegion(const HSerializedItem& SerializedItemHandle);

  // Serialize a region.
  HSerializedItem SerializeRegion() const;

  // Write regions to a file.
  void WriteRegion(const HString& FileName) const;

  // Write regions to a file.
  void WriteRegion(const char* FileName) const;

#ifdef _WIN32
  // Write regions to a file.
  void WriteRegion(const wchar_t* FileName) const;
#endif

  // Read binary images or HALCON regions.
  void ReadRegion(const HString& FileName);

  // Read binary images or HALCON regions.
  void ReadRegion(const char* FileName);

#ifdef _WIN32
  // Read binary images or HALCON regions.
  void ReadRegion(const wchar_t* FileName);
#endif

  // Geometric moments of regions.
  HTuple MomentsRegionCentralInvar(HTuple* PSI2, HTuple* PSI3, HTuple* PSI4) const;

  // Geometric moments of regions.
  double MomentsRegionCentralInvar(double* PSI2, double* PSI3, double* PSI4) const;

  // Geometric moments of regions.
  HTuple MomentsRegionCentral(HTuple* I2, HTuple* I3, HTuple* I4) const;

  // Geometric moments of regions.
  double MomentsRegionCentral(double* I2, double* I3, double* I4) const;

  // Geometric moments of regions.
  HTuple MomentsRegion3rdInvar(HTuple* M12, HTuple* M03, HTuple* M30) const;

  // Geometric moments of regions.
  double MomentsRegion3rdInvar(double* M12, double* M03, double* M30) const;

  // Geometric moments of regions.
  HTuple MomentsRegion3rd(HTuple* M12, HTuple* M03, HTuple* M30) const;

  // Geometric moments of regions.
  double MomentsRegion3rd(double* M12, double* M03, double* M30) const;

  // Smallest surrounding rectangle with any orientation.
  void SmallestRectangle2(HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2) const;

  // Smallest surrounding rectangle with any orientation.
  void SmallestRectangle2(double* Row, double* Column, double* Phi, double* Length1, double* Length2) const;

  // Surrounding rectangle parallel to the coordinate axes.
  void SmallestRectangle1(HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2) const;

  // Surrounding rectangle parallel to the coordinate axes.
  void SmallestRectangle1(Hlong* Row1, Hlong* Column1, Hlong* Row2, Hlong* Column2) const;

  // Smallest surrounding circle of a region.
  void SmallestCircle(HTuple* Row, HTuple* Column, HTuple* Radius) const;

  // Smallest surrounding circle of a region.
  void SmallestCircle(double* Row, double* Column, double* Radius) const;

  // Choose regions having a certain relation to each other.
  HRegion SelectShapeProto(const HRegion& Pattern, const HTuple& Feature, const HTuple& Min, const HTuple& Max) const;

  // Choose regions having a certain relation to each other.
  HRegion SelectShapeProto(const HRegion& Pattern, const HString& Feature, double Min, double Max) const;

  // Choose regions having a certain relation to each other.
  HRegion SelectShapeProto(const HRegion& Pattern, const char* Feature, double Min, double Max) const;

#ifdef _WIN32
  // Choose regions having a certain relation to each other.
  HRegion SelectShapeProto(const HRegion& Pattern, const wchar_t* Feature, double Min, double Max) const;
#endif

  // Calculate shape features of regions.
  HTuple RegionFeatures(const HTuple& Features) const;

  // Calculate shape features of regions.
  double RegionFeatures(const HString& Features) const;

  // Calculate shape features of regions.
  double RegionFeatures(const char* Features) const;

#ifdef _WIN32
  // Calculate shape features of regions.
  double RegionFeatures(const wchar_t* Features) const;
#endif

  // Choose regions with the aid of shape features.
  HRegion SelectShape(const HTuple& Features, const HString& Operation, const HTuple& Min, const HTuple& Max) const;

  // Choose regions with the aid of shape features.
  HRegion SelectShape(const HString& Features, const HString& Operation, double Min, double Max) const;

  // Choose regions with the aid of shape features.
  HRegion SelectShape(const char* Features, const char* Operation, double Min, double Max) const;

#ifdef _WIN32
  // Choose regions with the aid of shape features.
  HRegion SelectShape(const wchar_t* Features, const wchar_t* Operation, double Min, double Max) const;
#endif

  // Characteristic values for runlength coding of regions.
  HTuple RunlengthFeatures(HTuple* KFactor, HTuple* LFactor, HTuple* MeanLength, HTuple* Bytes) const;

  // Characteristic values for runlength coding of regions.
  Hlong RunlengthFeatures(double* KFactor, double* LFactor, double* MeanLength, Hlong* Bytes) const;

  // Search direct neighbors.
  HTuple FindNeighbors(const HRegion& Regions2, Hlong MaxDistance, HTuple* RegionIndex2) const;

  // Geometric moments of regions.
  HTuple MomentsRegion2ndRelInvar(HTuple* PHI2) const;

  // Geometric moments of regions.
  double MomentsRegion2ndRelInvar(double* PHI2) const;

  // Geometric moments of regions.
  HTuple MomentsRegion2ndInvar(HTuple* M20, HTuple* M02) const;

  // Geometric moments of regions.
  double MomentsRegion2ndInvar(double* M20, double* M02) const;

  // Calculate the geometric moments of regions.
  HTuple MomentsRegion2nd(HTuple* M20, HTuple* M02, HTuple* Ia, HTuple* Ib) const;

  // Calculate the geometric moments of regions.
  double MomentsRegion2nd(double* M20, double* M02, double* Ia, double* Ib) const;

  // Minimum distance between the contour pixels of two regions each.
  HTuple DistanceRrMin(const HRegion& Regions2, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2) const;

  // Minimum distance between the contour pixels of two regions each.
  double DistanceRrMin(const HRegion& Regions2, Hlong* Row1, Hlong* Column1, Hlong* Row2, Hlong* Column2) const;

  // Minimum distance between two regions with the help of dilation.
  HTuple DistanceRrMinDil(const HRegion& Regions2) const;

  // Maximal distance between two boundary points of a region.
  void DiameterRegion(HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2, HTuple* Diameter) const;

  // Maximal distance between two boundary points of a region.
  void DiameterRegion(Hlong* Row1, Hlong* Column1, Hlong* Row2, Hlong* Column2, double* Diameter) const;

  // Test if the region contains a given point.
  Hlong TestRegionPoint(const HTuple& Row, const HTuple& Column) const;

  // Test if the region contains a given point.
  Hlong TestRegionPoint(Hlong Row, Hlong Column) const;

  // Index of all regions containing a given pixel.
  HTuple GetRegionIndex(Hlong Row, Hlong Column) const;

  // Choose all regions containing a given pixel.
  HRegion SelectRegionPoint(Hlong Row, Hlong Column) const;

  // Select regions of a given shape.
  HRegion SelectShapeStd(const HString& Shape, double Percent) const;

  // Select regions of a given shape.
  HRegion SelectShapeStd(const char* Shape, double Percent) const;

#ifdef _WIN32
  // Select regions of a given shape.
  HRegion SelectShapeStd(const wchar_t* Shape, double Percent) const;
#endif

  // Hamming distance between two regions using normalization.
  HTuple HammingDistanceNorm(const HRegion& Regions2, const HTuple& Norm, HTuple* Similarity) const;

  // Hamming distance between two regions using normalization.
  Hlong HammingDistanceNorm(const HRegion& Regions2, const HString& Norm, double* Similarity) const;

  // Hamming distance between two regions using normalization.
  Hlong HammingDistanceNorm(const HRegion& Regions2, const char* Norm, double* Similarity) const;

#ifdef _WIN32
  // Hamming distance between two regions using normalization.
  Hlong HammingDistanceNorm(const HRegion& Regions2, const wchar_t* Norm, double* Similarity) const;
#endif

  // Hamming distance between two regions.
  HTuple HammingDistance(const HRegion& Regions2, HTuple* Similarity) const;

  // Hamming distance between two regions.
  Hlong HammingDistance(const HRegion& Regions2, double* Similarity) const;

  // Shape features derived from the ellipse parameters.
  HTuple Eccentricity(HTuple* Bulkiness, HTuple* StructureFactor) const;

  // Shape features derived from the ellipse parameters.
  double Eccentricity(double* Bulkiness, double* StructureFactor) const;

  // Calculate the Euler number.
  HTuple EulerNumber() const;

  // Orientation of a region.
  HTuple OrientationRegion() const;

  // Calculate the parameters of the equivalent ellipse.
  HTuple EllipticAxis(HTuple* Rb, HTuple* Phi) const;

  // Calculate the parameters of the equivalent ellipse.
  double EllipticAxis(double* Rb, double* Phi) const;

  // Pose relation of regions.
  HTuple SelectRegionSpatial(const HRegion& Regions2, const HString& Direction, HTuple* RegionIndex2) const;

  // Pose relation of regions.
  HTuple SelectRegionSpatial(const HRegion& Regions2, const char* Direction, HTuple* RegionIndex2) const;

#ifdef _WIN32
  // Pose relation of regions.
  HTuple SelectRegionSpatial(const HRegion& Regions2, const wchar_t* Direction, HTuple* RegionIndex2) const;
#endif

  // Pose relation of regions with regard to 
  HTuple SpatialRelation(const HRegion& Regions2, Hlong Percent, HTuple* RegionIndex2, HTuple* Relation1, HTuple* Relation2) const;

  // Shape factor for the convexity of a region.
  HTuple Convexity() const;

  // Contour length of a region.
  HTuple Contlength() const;

  // Number of connection components and holes
  HTuple ConnectAndHoles(HTuple* NumHoles) const;

  // Number of connection components and holes
  Hlong ConnectAndHoles(Hlong* NumHoles) const;

  // Shape factor for the rectangularity of a region.
  HTuple Rectangularity() const;

  // Shape factor for the compactness of a region.
  HTuple Compactness() const;

  // Shape factor for the circularity (similarity to a circle) of a region.
  HTuple Circularity() const;

  // Compute the area of holes of regions.
  HTuple AreaHoles() const;

  // Area and center of regions.
  HTuple AreaCenter(HTuple* Row, HTuple* Column) const;

  // Area and center of regions.
  Hlong AreaCenter(double* Row, double* Column) const;

  // Distribution of runs needed for runlength encoding of a region.
  HTuple RunlengthDistribution(HTuple* Background) const;

  // Shape factors from contour.
  HTuple Roundness(HTuple* Sigma, HTuple* Roundness, HTuple* Sides) const;

  // Shape factors from contour.
  double Roundness(double* Sigma, double* Roundness, double* Sides) const;

  // Largest inner rectangle of a region.
  void InnerRectangle1(HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2) const;

  // Largest inner rectangle of a region.
  void InnerRectangle1(Hlong* Row1, Hlong* Column1, Hlong* Row2, Hlong* Column2) const;

  // Largest inner circle of a region.
  void InnerCircle(HTuple* Row, HTuple* Column, HTuple* Radius) const;

  // Largest inner circle of a region.
  void InnerCircle(double* Row, double* Column, double* Radius) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  HTuple FitSurfaceFirstOrder(const HImage& Image, const HString& Algorithm, Hlong Iterations, double ClippingFactor, HTuple* Beta, HTuple* Gamma) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  double FitSurfaceFirstOrder(const HImage& Image, const HString& Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  double FitSurfaceFirstOrder(const HImage& Image, const char* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma) const;

#ifdef _WIN32
  // Calculate gray value moments and approximation by a first order surface (plane).
  double FitSurfaceFirstOrder(const HImage& Image, const wchar_t* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma) const;
#endif

  // Calculate gray value moments and approximation by a second order surface.
  HTuple FitSurfaceSecondOrder(const HImage& Image, const HString& Algorithm, Hlong Iterations, double ClippingFactor, HTuple* Beta, HTuple* Gamma, HTuple* Delta, HTuple* Epsilon, HTuple* Zeta) const;

  // Calculate gray value moments and approximation by a second order surface.
  double FitSurfaceSecondOrder(const HImage& Image, const HString& Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma, double* Delta, double* Epsilon, double* Zeta) const;

  // Calculate gray value moments and approximation by a second order surface.
  double FitSurfaceSecondOrder(const HImage& Image, const char* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma, double* Delta, double* Epsilon, double* Zeta) const;

#ifdef _WIN32
  // Calculate gray value moments and approximation by a second order surface.
  double FitSurfaceSecondOrder(const HImage& Image, const wchar_t* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma, double* Delta, double* Epsilon, double* Zeta) const;
#endif

  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoPoint(const HImage& Image, const HString& Feature, Hlong Row, Hlong Column, HTuple* RelativeHisto) const;

  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoPoint(const HImage& Image, const char* Feature, Hlong Row, Hlong Column, HTuple* RelativeHisto) const;

#ifdef _WIN32
  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoPoint(const HImage& Image, const wchar_t* Feature, Hlong Row, Hlong Column, HTuple* RelativeHisto) const;
#endif

  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoAll(const HImage& Image, const HString& Feature, HTuple* RelativeHisto) const;

  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoAll(const HImage& Image, const char* Feature, HTuple* RelativeHisto) const;

#ifdef _WIN32
  // Determine a histogram of features along all threshold values.
  HTuple ShapeHistoAll(const HImage& Image, const wchar_t* Feature, HTuple* RelativeHisto) const;
#endif

  // Calculates gray value features for a set of regions.
  HTuple GrayFeatures(const HImage& Image, const HTuple& Features) const;

  // Calculates gray value features for a set of regions.
  double GrayFeatures(const HImage& Image, const HString& Features) const;

  // Calculates gray value features for a set of regions.
  double GrayFeatures(const HImage& Image, const char* Features) const;

#ifdef _WIN32
  // Calculates gray value features for a set of regions.
  double GrayFeatures(const HImage& Image, const wchar_t* Features) const;
#endif

  // Select regions based on gray value features.
  HRegion SelectGray(const HImage& Image, const HTuple& Features, const HString& Operation, const HTuple& Min, const HTuple& Max) const;

  // Select regions based on gray value features.
  HRegion SelectGray(const HImage& Image, const HString& Features, const HString& Operation, double Min, double Max) const;

  // Select regions based on gray value features.
  HRegion SelectGray(const HImage& Image, const char* Features, const char* Operation, double Min, double Max) const;

#ifdef _WIN32
  // Select regions based on gray value features.
  HRegion SelectGray(const HImage& Image, const wchar_t* Features, const wchar_t* Operation, double Min, double Max) const;
#endif

  // Determine the minimum and maximum gray values within regions.
  void MinMaxGray(const HImage& Image, const HTuple& Percent, HTuple* Min, HTuple* Max, HTuple* Range) const;

  // Determine the minimum and maximum gray values within regions.
  void MinMaxGray(const HImage& Image, double Percent, double* Min, double* Max, double* Range) const;

  // Calculate the mean and deviation of gray values.
  HTuple Intensity(const HImage& Image, HTuple* Deviation) const;

  // Calculate the mean and deviation of gray values.
  double Intensity(const HImage& Image, double* Deviation) const;

  // Calculate the gray value distribution of a single channel image within a certain gray value range.
  HTuple GrayHistoRange(const HImage& Image, const HTuple& Min, const HTuple& Max, Hlong NumBins, double* BinSize) const;

  // Calculate the gray value distribution of a single channel image within a certain gray value range.
  Hlong GrayHistoRange(const HImage& Image, double Min, double Max, Hlong NumBins, double* BinSize) const;

  // Calculate the histogram of two-channel gray value images.
  HImage Histo2dim(const HImage& ImageCol, const HImage& ImageRow) const;

  // Calculate the gray value distribution.
  HTuple GrayHistoAbs(const HImage& Image, const HTuple& Quantization) const;

  // Calculate the gray value distribution.
  HTuple GrayHistoAbs(const HImage& Image, double Quantization) const;

  // Calculate the gray value distribution.
  HTuple GrayHisto(const HImage& Image, HTuple* RelativeHisto) const;

  // Determine the entropy and anisotropy of images.
  HTuple EntropyGray(const HImage& Image, HTuple* Anisotropy) const;

  // Determine the entropy and anisotropy of images.
  double EntropyGray(const HImage& Image, double* Anisotropy) const;

  // Calculate a co-occurrence matrix and derive gray value features thereof.
  HTuple CoocFeatureImage(const HImage& Image, Hlong LdGray, const HTuple& Direction, HTuple* Correlation, HTuple* Homogeneity, HTuple* Contrast) const;

  // Calculate a co-occurrence matrix and derive gray value features thereof.
  double CoocFeatureImage(const HImage& Image, Hlong LdGray, Hlong Direction, double* Correlation, double* Homogeneity, double* Contrast) const;

  // Calculate the co-occurrence matrix of a region in an image.
  HImage GenCoocMatrix(const HImage& Image, Hlong LdGray, Hlong Direction) const;

  // Calculate gray value moments and approximation by a plane.
  void MomentsGrayPlane(const HImage& Image, HTuple* MRow, HTuple* MCol, HTuple* Alpha, HTuple* Beta, HTuple* Mean) const;

  // Calculate gray value moments and approximation by a plane.
  void MomentsGrayPlane(const HImage& Image, double* MRow, double* MCol, double* Alpha, double* Beta, double* Mean) const;

  // Calculate the deviation of the gray values from the approximating image plane.
  HTuple PlaneDeviation(const HImage& Image) const;

  // Compute the orientation and major axes of a region in a gray value image.
  HTuple EllipticAxisGray(const HImage& Image, HTuple* Rb, HTuple* Phi) const;

  // Compute the orientation and major axes of a region in a gray value image.
  double EllipticAxisGray(const HImage& Image, double* Rb, double* Phi) const;

  // Compute the area and center of gravity of a region in a gray value image.
  HTuple AreaCenterGray(const HImage& Image, HTuple* Row, HTuple* Column) const;

  // Compute the area and center of gravity of a region in a gray value image.
  double AreaCenterGray(const HImage& Image, double* Row, double* Column) const;

  // Calculate horizontal and vertical gray-value projections.
  HTuple GrayProjections(const HImage& Image, const HString& Mode, HTuple* VertProjection) const;

  // Calculate horizontal and vertical gray-value projections.
  HTuple GrayProjections(const HImage& Image, const char* Mode, HTuple* VertProjection) const;

#ifdef _WIN32
  // Calculate horizontal and vertical gray-value projections.
  HTuple GrayProjections(const HImage& Image, const wchar_t* Mode, HTuple* VertProjection) const;
#endif

  // Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
  HImage GrabDataAsync(HXLDCont* Contours, const HFramegrabber& AcqHandle, double MaxDelay, HTuple* Data);

  // Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
  HImage GrabDataAsync(HXLDCont* Contours, const HFramegrabber& AcqHandle, double MaxDelay, HString* Data);

  // Synchronous grab of images and preprocessed image data from the specified image acquisition device.
  HImage GrabData(HXLDCont* Contours, const HFramegrabber& AcqHandle, HTuple* Data);

  // Synchronous grab of images and preprocessed image data from the specified image acquisition device.
  HImage GrabData(HXLDCont* Contours, const HFramegrabber& AcqHandle, HString* Data);

  // Classify multiple characters with an CNN-based OCR classifier.
  HTuple DoOcrMultiClassCnn(const HImage& Image, const HOCRCnn& OCRHandle, HTuple* Confidence) const;

  // Classify multiple characters with an CNN-based OCR classifier.
  HString DoOcrMultiClassCnn(const HImage& Image, const HOCRCnn& OCRHandle, double* Confidence) const;

  // Classify a single character with an CNN-based OCR classifier.
  HTuple DoOcrSingleClassCnn(const HImage& Image, const HOCRCnn& OCRHandle, const HTuple& Num, HTuple* Confidence) const;

  // Classify a single character with an CNN-based OCR classifier.
  HString DoOcrSingleClassCnn(const HImage& Image, const HOCRCnn& OCRHandle, const HTuple& Num, double* Confidence) const;

  // Classify a related group of characters with an CNN-based OCR classifier.
  HTuple DoOcrWordCnn(const HImage& Image, const HOCRCnn& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, HTuple* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an CNN-based OCR classifier.
  HString DoOcrWordCnn(const HImage& Image, const HOCRCnn& OCRHandle, const HString& Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

  // Classify a related group of characters with an CNN-based OCR classifier.
  HString DoOcrWordCnn(const HImage& Image, const HOCRCnn& OCRHandle, const char* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;

#ifdef _WIN32
  // Classify a related group of characters with an CNN-based OCR classifier.
  HString DoOcrWordCnn(const HImage& Image, const HOCRCnn& OCRHandle, const wchar_t* Expression, Hlong NumAlternatives, Hlong NumCorrections, double* Confidence, HString* Word, double* Score) const;
#endif

  // Compute the width, height, and aspect ratio of the surrounding rectangle parallel to the coordinate axes.
  HTuple HeightWidthRatio(HTuple* Width, HTuple* Ratio) const;

  // Compute the width, height, and aspect ratio of the surrounding rectangle parallel to the coordinate axes.
  Hlong HeightWidthRatio(Hlong* Width, double* Ratio) const;

  // Insert objects into an iconic object tuple.
  HRegion InsertObj(const HRegion& ObjectsInsert, Hlong Index) const;

  // Remove objects from an iconic object tuple.
  HRegion RemoveObj(const HTuple& Index) const;

  // Remove objects from an iconic object tuple.
  HRegion RemoveObj(Hlong Index) const;

  // Replaces one or more elements of an iconic object tuple.
  HRegion ReplaceObj(const HRegion& ObjectsReplace, const HTuple& Index) const;

  // Replaces one or more elements of an iconic object tuple.
  HRegion ReplaceObj(const HRegion& ObjectsReplace, Hlong Index) const;

private:

  // Verify matching semantic type ('region')!
  void AssertObjectClass();

};

}

#endif
